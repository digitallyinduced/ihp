Lazy session decryption and conditional cookie encryption

Defers cookie decryption until the session is first read or written.

When the session is read but not modified, the original encrypted cookie
bytes are returned without re-encrypting. This refreshes the browser's
max-age timer (preventing expiry 30 days from login rather than 30 days
from last visit) with zero crypto cost.

When the session is never accessed, Nothing is returned, signaling to
wai-session's withSession to skip the Set-Cookie header entirely.

diff -ruN a/Network/Wai/Session/ClientSession.hs b/Network/Wai/Session/ClientSession.hs
--- a/Network/Wai/Session/ClientSession.hs
+++ b/Network/Wai/Session/ClientSession.hs
@@ -10,25 +10,52 @@
 import Web.ClientSession (Key, encryptIO, decrypt)
 import Data.Serialize (encode, decode, Serialize) -- Use cereal because clientsession does

+-- | Lazy session state: defers decryption until first access
+data SessionState k v
+	= Unloaded                     -- ^ Cookie present, not yet decrypted
+	| Loaded ![(k, v)] !Bool       -- ^ Decrypted pairs + dirty flag
+	| NoCookie                     -- ^ No cookie was present
+
 -- | Session store that keeps all content in a 'Serialize'd cookie encrypted
 -- with 'Web.ClientSession'
 --
+-- Decryption is deferred until the session is first read or written.
+-- The Set-Cookie header is skipped when the session is never accessed.
+--
 -- WARNING: This session is vulnerable to sidejacking,
 -- use with TLS for security.
 clientsessionStore :: (Serialize k, Serialize v, Eq k, MonadIO m) => Key -> SessionStore m k v
-clientsessionStore cryptKey (Just encoded) =
-	case hush . decode =<< decrypt cryptKey encoded of
-		Just sessionData -> backend cryptKey sessionData
-		-- Bad cookie is the same as no cookie
-		Nothing -> clientsessionStore cryptKey Nothing
-clientsessionStore cryptKey Nothing = backend cryptKey []
+clientsessionStore cryptKey maybeCookie = do
+	stateRef <- newIORef $ case maybeCookie of
+		Nothing -> NoCookie
+		Just _  -> Unloaded
+
+	let decryptSession = case maybeCookie of
+		Nothing -> return []
+		Just encoded -> case hush . decode =<< decrypt cryptKey encoded of
+			Just sessionData -> return sessionData
+			Nothing -> return []
+
+	let ensureLoaded = do
+		state <- readIORef stateRef
+		case state of
+			Unloaded -> do
+				pairs <- decryptSession
+				writeIORef stateRef (Loaded pairs False)
+				return pairs
+			Loaded pairs _ -> return pairs
+			NoCookie -> return []

-backend :: (Serialize k, Serialize v, Eq k, MonadIO m) => Key -> [(k, v)] -> IO (Session m k v, IO ByteString)
-backend cryptKey sessionData = do
-	-- Don't need threadsafety because we only hand this IORef to an Application
-	-- through a single Request.
-	ref <- newIORef sessionData
 	return ((
-			(\k -> lookup k `liftM` liftIO (readIORef ref)),
-			(\k v -> liftIO (modifyIORef ref (((k,v):) . filter ((/=k) . fst))))
-		), encryptIO cryptKey =<< encode `fmap` readIORef ref)
+			(\k -> lookup k `liftM` liftIO ensureLoaded),
+			(\k v -> liftIO $ do
+				pairs <- ensureLoaded
+				writeIORef stateRef (Loaded (((k,v):) . filter ((/=k) . fst) $ pairs) True))
+		), do
+			state <- readIORef stateRef
+			case state of
+				Loaded pairs True ->
+					Just <$> (encryptIO cryptKey $ encode pairs)
+				Loaded _     False -> return maybeCookie
+				_                  -> return Nothing
+		)
