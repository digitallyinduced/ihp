{-# LANGUAGE TypeFamilies, DataKinds, MultiParamTypeClasses, PolyKinds, TypeApplications, ScopedTypeVariables, ConstraintKinds, TypeOperators, GADTs, UndecidableInstances, StandaloneDeriving, FunctionalDependencies, FlexibleContexts, AllowAmbiguousTypes, FlexibleInstances #-}
{-|
Module: IHP.FetchRelated
Description:  Provides fetchRelated, collectionFetchRelated, etc.
Copyright: (c) digitally induced GmbH, 2020

This modules provides helper functions to access relationshops for a model.

See https://ihp.digitallyinduced.com/Guide/relationships.html for some examples.
-}
module IHP.FetchRelated (fetchRelated, collectionFetchRelated, collectionFetchRelatedOrNothing, fetchRelatedOrNothing, maybeFetchRelatedOrNothing, collectionFetchRelatedById, collectionFetchRelatedOrNothingById) where

import IHP.Prelude
import IHP.ModelSupport (Include, PrimaryKey, GetModelByTableName, Table, GetTableForId)
import IHP.QueryBuilder
import IHP.Fetch
import IHP.Hasql.FromRow (FromRowHasql)
import Hasql.Implicits.Encoders (DefaultParamEncoder)

-- | This class provides the collectionFetchRelated function
--
-- This function is provided by this class as we have to deal with two cases:
--
-- 1. the related field is a id, e.g. like the company ids in @users |> collectionFetchRelated #companyId@
-- 2. the related field is a query builder, e.g. in @posts |> collectionFetchRelated #comments@
class CollectionFetchRelated relatedFieldValue relatedModel where
    collectionFetchRelated :: forall model relatedField. (
            ?modelContext :: ModelContext,
            HasField relatedField model relatedFieldValue,
            UpdateField relatedField model (Include relatedField model) relatedFieldValue (FetchResult relatedFieldValue relatedModel),
            Fetchable relatedFieldValue relatedModel,
            KnownSymbol (GetTableName relatedModel),
            FromRowHasql relatedModel,
            KnownSymbol relatedField
        ) => Proxy relatedField -> [model] -> IO [Include relatedField model]

-- | This class provides the collectionFetchRelatedOrNothing function
--
-- This function is provided by this class as we have to deal with two cases:
--
-- 1. the related field is an id, e.g. like the company ids in @users |> collectionFetchRelated #companyId@
-- 2. the related field is a query builder, e.g. in @posts |> collectionFetchRelated #comments@
class CollectionFetchRelatedOrNothing relatedFieldValue relatedModel where
    collectionFetchRelatedOrNothing :: forall model relatedField. (
            ?modelContext :: ModelContext,
            HasField relatedField model (Maybe relatedFieldValue),
            UpdateField relatedField model (Include relatedField model) (Maybe relatedFieldValue) (Maybe (FetchResult relatedFieldValue relatedModel)),
            Fetchable relatedFieldValue relatedModel,
            KnownSymbol (GetTableName relatedModel),
            FromRowHasql relatedModel,
            KnownSymbol relatedField
        ) => Proxy relatedField -> [model] -> IO [Include relatedField model]

-- | Provides collectionFetchRelated for ids, e.g. @collectionFetchRelated #companyId@
--
-- When we want to fetch all the users with their companies, we can use collectionFetchRelated like this:
--
-- > users <- query @User
-- >     |> fetch
-- >     >>= collectionFetchRelated #companyId
--
-- This will query all users with their company. The type of @users@ is @[Include "companyId" User]@.
--
-- This example will trigger only two SQL queries:
-- 
-- > SELECT * FROM users
-- > SELECT * FROM companies WHERE id IN (?)
-- CollectionFetchRelated instances for per-table Id newtypes (UserId, ProjectId, etc.)
-- are generated by the schema compiler in Generated.ActualTypes.PrimaryKeys.

-- | Provides collectionFetchRelatedOrNothing for nullable ids, e.g. @collectionFetchRelatedOrNothing #companyId@
--
-- When we want to fetch all the users with their companies, we can use collectionFetchRelatedOrNothing like this:
--
-- > users <- query @User
-- >     |> fetch
-- >     >>= collectionFetchRelatedOrNothing #companyId
--
-- This will query all users with their company. The type of @users@ is @[Include "companyId" User]@.
--
-- This example will trigger only two SQL queries:
-- 
-- > SELECT * FROM users
-- > SELECT * FROM companies WHERE id IN (?)
-- CollectionFetchRelatedOrNothing instances for per-table Id newtypes (UserId, ProjectId, etc.)
-- are generated by the schema compiler in Generated.ActualTypes.PrimaryKeys.

-- | Helper used by generated CollectionFetchRelated instances for Id newtypes
collectionFetchRelatedById :: forall id relatedModel model relatedField.
    ( ?modelContext :: ModelContext
    , HasField relatedField model id
    , IdNewtype id (PrimaryKey (GetTableForId id))
    , id ~ Id' (GetTableForId id)
    , Eq id, Show id
    , Table relatedModel
    , GetTableName relatedModel ~ GetTableForId id
    , relatedModel ~ GetModelByTableName (GetTableForId id)
    , HasField "id" relatedModel id
    , UpdateField relatedField model (Include relatedField model) id relatedModel
    , KnownSymbol (GetTableName relatedModel)
    , FromRowHasql relatedModel
    , KnownSymbol relatedField
    , DefaultParamEncoder [PrimaryKey (GetTableForId id)]
    ) => Proxy relatedField -> [model] -> IO [Include relatedField model]
collectionFetchRelatedById relatedField model = do
    relatedModels :: [relatedModel] <- query @relatedModel |> filterWhereIdIn (map (getField @relatedField) model) |> fetch
    let
        assignRelated m =
            let
                rm :: relatedModel
                rm = case find (\r -> r.id == tf) relatedModels of
                        Just x -> x
                        Nothing -> error ("Could not find record with id = " <> show tf <> " in result set. Looks like the foreign key is pointing to a non existing record")
                tf = (getField @relatedField m :: id)
            in
                updateField @relatedField rm m
    pure (map assignRelated model)

-- | Helper used by generated CollectionFetchRelatedOrNothing instances for Id newtypes
collectionFetchRelatedOrNothingById :: forall id relatedModel model relatedField.
    ( ?modelContext :: ModelContext
    , HasField relatedField model (Maybe id)
    , IdNewtype id (PrimaryKey (GetTableForId id))
    , id ~ Id' (GetTableForId id)
    , Eq id
    , Table relatedModel
    , GetTableName relatedModel ~ GetTableForId id
    , relatedModel ~ GetModelByTableName (GetTableForId id)
    , HasField "id" relatedModel id
    , UpdateField relatedField model (Include relatedField model) (Maybe id) (Maybe relatedModel)
    , KnownSymbol (GetTableName relatedModel)
    , FromRowHasql relatedModel
    , KnownSymbol relatedField
    , DefaultParamEncoder [PrimaryKey (GetTableForId id)]
    ) => Proxy relatedField -> [model] -> IO [Include relatedField model]
collectionFetchRelatedOrNothingById relatedField model = do
    relatedModels :: [relatedModel] <- query @relatedModel |> filterWhereIdIn (mapMaybe (getField @relatedField) model) |> fetch
    let
        assignRelated m =
            let
                rm :: Maybe relatedModel
                rm = find (\r -> Just r.id == tf) relatedModels
                tf = (getField @relatedField m :: Maybe id)
            in
                updateField @relatedField rm m
    pure (map assignRelated model)

-- | Provides collectionFetchRelated for QueryBuilder's, e.g. @collectionFetchRelated #comments@
--
-- When we want to fetch all the comments for a list of posts, we can use collectionFetchRelated like this:
--
-- > posts <- query @Post
-- >     |> fetch
-- >     >>= collectionFetchRelated #comments
--
-- This will query all posts with their comments. The type of @posts@ is @[Include "comments" Post]@.
--
-- When fetching query builders, currently the implementation is not very efficient. E.g. given 10 Posts above, it will run 10 queries to fetch the comments. We should optimise this behavior in the future.
instance (relatedModel ~ GetModelByTableName relatedTable, Table relatedModel) => CollectionFetchRelated (QueryBuilder relatedTable) relatedModel where
    collectionFetchRelated :: forall model relatedField. (
            ?modelContext :: ModelContext,
            HasField relatedField model (QueryBuilder relatedTable),
            UpdateField relatedField model (Include relatedField model) (QueryBuilder relatedTable) (FetchResult (QueryBuilder relatedTable) relatedModel),
            Fetchable (QueryBuilder relatedTable) relatedModel,
            KnownSymbol (GetTableName relatedModel),
            FromRowHasql relatedModel,
            KnownSymbol relatedField
        ) => Proxy relatedField -> [model] -> IO [Include relatedField model]
    collectionFetchRelated relatedField models = do
        let fetchRelated model = do
                let queryBuilder :: QueryBuilder relatedTable = getField @relatedField model
                result :: [relatedModel] <- fetch queryBuilder
                pure (updateField @relatedField result model)
        mapM fetchRelated models

-- Fetches a related record
--
-- Given a specific post, we can fetch the post and all its comments like this:
--
-- > let postId :: Id Post = ...
-- > 
-- > post <- fetch postId
-- >     >>= fetchRelated #comments
--
-- This Haskell code will trigger the following SQL queries to be executed:
--
-- > SELECT posts.* FROM posts WHERE id = ?  LIMIT 1
-- > SELECT comments.* FROM comments WHERE post_id = ?
--
-- In the view we can just access the comments like this:
--
-- > [hsx|
-- >     <h1>{post.title}</h1>
-- >     <h2>Comments:</h2>
-- >     {post.comments}
-- > |]
--
-- The @post.comments@ returns a list of the comments belonging to the post.
-- The type of post is @Include "comments"@ Post instead of the usual @Post@. This way the state of a fetched nested resource is tracked at the type level.
--
fetchRelated :: forall model field fieldValue fetchModel. (
        ?modelContext :: ModelContext,
        UpdateField field model (Include field model) fieldValue (FetchResult fieldValue fetchModel),
        HasField field model fieldValue,
        FromRowHasql fetchModel,
        KnownSymbol (GetTableName fetchModel),
        Fetchable fieldValue fetchModel,
        Table fetchModel
    ) => Proxy field -> model -> IO (Include field model)
fetchRelated relatedField model = do
    result :: FetchResult fieldValue fetchModel <- fetch ((getField @field model) :: fieldValue)
    let model' = updateField @field result model
    pure model'
{-# INLINE fetchRelated #-}

fetchRelatedOrNothing :: forall model field fieldValue fetchModel. (
        ?modelContext :: ModelContext,
        UpdateField field model (Include field model) (Maybe fieldValue) (Maybe (FetchResult fieldValue fetchModel)),
        HasField field model (Maybe fieldValue),
        FromRowHasql fetchModel,
        KnownSymbol (GetTableName fetchModel),
        Fetchable fieldValue fetchModel,
        Table fetchModel
    ) => Proxy field -> model -> IO (Include field model)
fetchRelatedOrNothing relatedField model = do
    result :: Maybe (FetchResult fieldValue fetchModel) <- case getField @field model of
            Just fieldValue -> Just <$> fetch fieldValue
            Nothing -> pure Nothing
    let model' = updateField @field result model
    pure model'
{-# INLINE fetchRelatedOrNothing #-}

maybeFetchRelatedOrNothing :: forall model field fieldValue fetchModel. (
        ?modelContext :: ModelContext,
        UpdateField field model (Include field model) (Maybe fieldValue) (Maybe (FetchResult fieldValue fetchModel)),
        HasField field model (Maybe fieldValue),
        FromRowHasql fetchModel,
        KnownSymbol (GetTableName fetchModel),
        Fetchable fieldValue fetchModel,
        Table fetchModel
    ) => Proxy field -> Maybe model -> IO (Maybe (Include field model))
maybeFetchRelatedOrNothing relatedField = maybe (pure Nothing) (\q -> fetchRelatedOrNothing relatedField q >>= pure . Just)
{-# INLINE maybeFetchRelatedOrNothing #-}
