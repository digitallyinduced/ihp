{-# LANGUAGE MultiParamTypeClasses, TypeFamilies, FlexibleContexts, AllowAmbiguousTypes, UndecidableInstances, FlexibleInstances, DataKinds, TypeApplications, ScopedTypeVariables, DefaultSignatures #-}

{-|
Module: IHP.Hasql.FromRow
Description: Typeclass for decoding hasql result rows
Copyright: (c) digitally induced GmbH, 2025

This module provides 'FromRowHasql', a typeclass parallel to postgresql-simple's 'FromRow',
for decoding database rows using hasql's more efficient prepared statement approach.

Instances are generated by the SchemaCompiler alongside the existing 'FromRow' instances.
-}
module IHP.Hasql.FromRow
( FromRowHasql (..)
, HasqlColumn (..)
) where

import IHP.Prelude
import qualified Hasql.Decoders as Decoders
import Data.UUID (UUID)
import Data.Time.Clock (UTCTime)
import Data.Time.LocalTime (LocalTime, TimeOfDay)
import Data.Time.Calendar (Day)
import Data.Scientific (Scientific)
import Data.Aeson (Value)
import qualified Data.Vector as Vector
import IHP.Postgres.Point (Point(..))
import IHP.Postgres.Polygon (Polygon(..))
import IHP.Postgres.TSVector (TSVector(..), Lexeme(..), LexemeRanking(..))
import qualified Data.Text.Encoding as Text
import qualified Data.Attoparsec.ByteString.Char8 as Attoparsec
import Data.Attoparsec.ByteString.Char8 (skipSpace, char, option, choice, double, skipMany, many1, many', sepBy)

-- | Typeclass for types that can be decoded from a hasql result row
--
-- This is the hasql equivalent of postgresql-simple's 'FromRow' class.
-- The SchemaCompiler generates instances for all model types.
class FromRowHasql a where
    -- | Decoder for a single row
    hasqlRowDecoder :: Decoders.Row a

-- | Typeclass for types that can be decoded from a single hasql column
--
-- This is used by the generated 'FromRowHasql' instances.
class HasqlColumn a where
    hasqlColumn :: Decoders.Row a

-- Primitive type instances

instance HasqlColumn UUID where
    hasqlColumn = Decoders.column (Decoders.nonNullable Decoders.uuid)
    {-# INLINE hasqlColumn #-}

instance HasqlColumn (Maybe UUID) where
    hasqlColumn = Decoders.column (Decoders.nullable Decoders.uuid)
    {-# INLINE hasqlColumn #-}

instance HasqlColumn Text where
    hasqlColumn = Decoders.column (Decoders.nonNullable Decoders.text)
    {-# INLINE hasqlColumn #-}

instance HasqlColumn (Maybe Text) where
    hasqlColumn = Decoders.column (Decoders.nullable Decoders.text)
    {-# INLINE hasqlColumn #-}

instance HasqlColumn Int where
    hasqlColumn = Decoders.column (Decoders.nonNullable (fromIntegral <$> Decoders.int8))
    {-# INLINE hasqlColumn #-}

instance HasqlColumn (Maybe Int) where
    hasqlColumn = Decoders.column (Decoders.nullable (fromIntegral <$> Decoders.int8))
    {-# INLINE hasqlColumn #-}

instance HasqlColumn Integer where
    hasqlColumn = Decoders.column (Decoders.nonNullable (fromIntegral <$> Decoders.int8))
    {-# INLINE hasqlColumn #-}

instance HasqlColumn (Maybe Integer) where
    hasqlColumn = Decoders.column (Decoders.nullable (fromIntegral <$> Decoders.int8))
    {-# INLINE hasqlColumn #-}

instance HasqlColumn Int64 where
    hasqlColumn = Decoders.column (Decoders.nonNullable Decoders.int8)
    {-# INLINE hasqlColumn #-}

instance HasqlColumn (Maybe Int64) where
    hasqlColumn = Decoders.column (Decoders.nullable Decoders.int8)
    {-# INLINE hasqlColumn #-}

instance HasqlColumn Bool where
    hasqlColumn = Decoders.column (Decoders.nonNullable Decoders.bool)
    {-# INLINE hasqlColumn #-}

instance HasqlColumn (Maybe Bool) where
    hasqlColumn = Decoders.column (Decoders.nullable Decoders.bool)
    {-# INLINE hasqlColumn #-}

instance HasqlColumn Double where
    hasqlColumn = Decoders.column (Decoders.nonNullable Decoders.float8)
    {-# INLINE hasqlColumn #-}

instance HasqlColumn (Maybe Double) where
    hasqlColumn = Decoders.column (Decoders.nullable Decoders.float8)
    {-# INLINE hasqlColumn #-}

instance HasqlColumn Float where
    hasqlColumn = Decoders.column (Decoders.nonNullable Decoders.float4)
    {-# INLINE hasqlColumn #-}

instance HasqlColumn (Maybe Float) where
    hasqlColumn = Decoders.column (Decoders.nullable Decoders.float4)
    {-# INLINE hasqlColumn #-}

instance HasqlColumn UTCTime where
    hasqlColumn = Decoders.column (Decoders.nonNullable Decoders.timestamptz)
    {-# INLINE hasqlColumn #-}

instance HasqlColumn (Maybe UTCTime) where
    hasqlColumn = Decoders.column (Decoders.nullable Decoders.timestamptz)
    {-# INLINE hasqlColumn #-}

instance HasqlColumn LocalTime where
    hasqlColumn = Decoders.column (Decoders.nonNullable Decoders.timestamp)
    {-# INLINE hasqlColumn #-}

instance HasqlColumn (Maybe LocalTime) where
    hasqlColumn = Decoders.column (Decoders.nullable Decoders.timestamp)
    {-# INLINE hasqlColumn #-}

instance HasqlColumn Day where
    hasqlColumn = Decoders.column (Decoders.nonNullable Decoders.date)
    {-# INLINE hasqlColumn #-}

instance HasqlColumn (Maybe Day) where
    hasqlColumn = Decoders.column (Decoders.nullable Decoders.date)
    {-# INLINE hasqlColumn #-}

instance HasqlColumn TimeOfDay where
    hasqlColumn = Decoders.column (Decoders.nonNullable Decoders.time)
    {-# INLINE hasqlColumn #-}

instance HasqlColumn (Maybe TimeOfDay) where
    hasqlColumn = Decoders.column (Decoders.nullable Decoders.time)
    {-# INLINE hasqlColumn #-}

instance HasqlColumn Scientific where
    hasqlColumn = Decoders.column (Decoders.nonNullable Decoders.numeric)
    {-# INLINE hasqlColumn #-}

instance HasqlColumn (Maybe Scientific) where
    hasqlColumn = Decoders.column (Decoders.nullable Decoders.numeric)
    {-# INLINE hasqlColumn #-}

instance HasqlColumn ByteString where
    hasqlColumn = Decoders.column (Decoders.nonNullable Decoders.bytea)
    {-# INLINE hasqlColumn #-}

instance HasqlColumn (Maybe ByteString) where
    hasqlColumn = Decoders.column (Decoders.nullable Decoders.bytea)
    {-# INLINE hasqlColumn #-}

instance HasqlColumn Value where
    hasqlColumn = Decoders.column (Decoders.nonNullable Decoders.jsonb)
    {-# INLINE hasqlColumn #-}

instance HasqlColumn (Maybe Value) where
    hasqlColumn = Decoders.column (Decoders.nullable Decoders.jsonb)
    {-# INLINE hasqlColumn #-}

-- Array instances

instance HasqlColumn [UUID] where
    hasqlColumn = Decoders.column (Decoders.nonNullable (Decoders.listArray (Decoders.nonNullable Decoders.uuid)))
    {-# INLINE hasqlColumn #-}

instance HasqlColumn (Maybe [UUID]) where
    hasqlColumn = Decoders.column (Decoders.nullable (Decoders.listArray (Decoders.nonNullable Decoders.uuid)))
    {-# INLINE hasqlColumn #-}

instance HasqlColumn [Text] where
    hasqlColumn = Decoders.column (Decoders.nonNullable (Decoders.listArray (Decoders.nonNullable Decoders.text)))
    {-# INLINE hasqlColumn #-}

instance HasqlColumn (Maybe [Text]) where
    hasqlColumn = Decoders.column (Decoders.nullable (Decoders.listArray (Decoders.nonNullable Decoders.text)))
    {-# INLINE hasqlColumn #-}

instance HasqlColumn [Int] where
    hasqlColumn = Decoders.column (Decoders.nonNullable (Decoders.listArray (Decoders.nonNullable (fromIntegral <$> Decoders.int8))))
    {-# INLINE hasqlColumn #-}

instance HasqlColumn (Maybe [Int]) where
    hasqlColumn = Decoders.column (Decoders.nullable (Decoders.listArray (Decoders.nonNullable (fromIntegral <$> Decoders.int8))))
    {-# INLINE hasqlColumn #-}

instance HasqlColumn [Integer] where
    hasqlColumn = Decoders.column (Decoders.nonNullable (Decoders.listArray (Decoders.nonNullable (fromIntegral <$> Decoders.int8))))
    {-# INLINE hasqlColumn #-}

instance HasqlColumn (Maybe [Integer]) where
    hasqlColumn = Decoders.column (Decoders.nullable (Decoders.listArray (Decoders.nonNullable (fromIntegral <$> Decoders.int8))))
    {-# INLINE hasqlColumn #-}

instance HasqlColumn [Bool] where
    hasqlColumn = Decoders.column (Decoders.nonNullable (Decoders.listArray (Decoders.nonNullable Decoders.bool)))
    {-# INLINE hasqlColumn #-}

instance HasqlColumn (Maybe [Bool]) where
    hasqlColumn = Decoders.column (Decoders.nullable (Decoders.listArray (Decoders.nonNullable Decoders.bool)))
    {-# INLINE hasqlColumn #-}

instance HasqlColumn [Double] where
    hasqlColumn = Decoders.column (Decoders.nonNullable (Decoders.listArray (Decoders.nonNullable Decoders.float8)))
    {-# INLINE hasqlColumn #-}

instance HasqlColumn (Maybe [Double]) where
    hasqlColumn = Decoders.column (Decoders.nullable (Decoders.listArray (Decoders.nonNullable Decoders.float8)))
    {-# INLINE hasqlColumn #-}

-- Point type (custom IHP type)
-- Point is decoded from the text representation "(x,y)"
instance HasqlColumn Point where
    hasqlColumn = Decoders.column (Decoders.nonNullable (Decoders.refine parsePointText Decoders.bytea))
    {-# INLINE hasqlColumn #-}

instance HasqlColumn (Maybe Point) where
    hasqlColumn = Decoders.column (Decoders.nullable (Decoders.refine parsePointText Decoders.bytea))
    {-# INLINE hasqlColumn #-}

-- Polygon type (custom IHP type)
-- Polygon is decoded from the text representation "((x1,y1),(x2,y2),...)"
instance HasqlColumn Polygon where
    hasqlColumn = Decoders.column (Decoders.nonNullable (Decoders.refine parsePolygonText Decoders.bytea))
    {-# INLINE hasqlColumn #-}

instance HasqlColumn (Maybe Polygon) where
    hasqlColumn = Decoders.column (Decoders.nullable (Decoders.refine parsePolygonText Decoders.bytea))
    {-# INLINE hasqlColumn #-}

-- TSVector decoded from text using a custom parser
-- The parser matches the one in IHP.Postgres.TSVector for postgresql-simple
instance HasqlColumn TSVector where
    hasqlColumn = Decoders.column (Decoders.nonNullable (Decoders.refine parseTSVectorText Decoders.bytea))
    {-# INLINE hasqlColumn #-}

instance HasqlColumn (Maybe TSVector) where
    hasqlColumn = Decoders.column (Decoders.nullable (Decoders.refine parseTSVectorText Decoders.bytea))
    {-# INLINE hasqlColumn #-}

-- | Parse tsvector text representation to TSVector
-- Format: 'word1':1A,2B 'word2':3C
parseTSVectorText :: ByteString -> Either Text TSVector
parseTSVectorText bs = case Attoparsec.parseOnly parseTSVector bs of
    Left err -> Left (cs err)
    Right val -> Right val

-- | Attoparsec parser for tsvector format
-- This matches the parser in IHP.Postgres.TSVector
parseTSVector :: Attoparsec.Parser TSVector
parseTSVector = TSVector <$> many' parseLexeme
    where
        parseLexeme = do
            skipSpace
            char '\''
            token <- Attoparsec.takeWhile (/= '\'')
            char '\''
            char ':'
            ranking <- many1 do
                skipMany $ char ','
                position <- double
                -- The Default Weight Is `D` So Postgres Does Not Include It In The Result
                weight <- option 'D' $ choice [char 'A', char 'B', char 'C', char 'D']
                pure $ LexemeRanking { position = truncate position, weight }
            pure $ Lexeme { token = Text.decodeUtf8 token, ranking }

-- | Parse point text representation to Point
-- Format: (x,y)
parsePointText :: ByteString -> Either Text Point
parsePointText bs = case Attoparsec.parseOnly parsePoint bs of
    Left err -> Left (cs err)
    Right val -> Right val

-- | Attoparsec parser for point format
-- This matches the parser in IHP.Postgres.Point
parsePoint :: Attoparsec.Parser Point
parsePoint = do
    Attoparsec.string "("
    x <- doubleOrNaN
    Attoparsec.string ","
    y <- doubleOrNaN
    Attoparsec.string ")"
    pure $ Point { x, y }
    where
        -- Postgres supports storing NaN inside a point
        doubleOrNaN = double <|> (Attoparsec.string "NaN" >> (pure $ 0 / 0))

-- | Parse polygon text representation to Polygon
-- Format: ((x1,y1),(x2,y2),...)
parsePolygonText :: ByteString -> Either Text Polygon
parsePolygonText bs = case Attoparsec.parseOnly parsePolygon bs of
    Left err -> Left (cs err)
    Right val -> Right val

-- | Attoparsec parser for polygon format
-- This matches the parser in IHP.Postgres.Polygon
parsePolygon :: Attoparsec.Parser Polygon
parsePolygon = do
    Attoparsec.string "("
    points <- parsePoint `Attoparsec.sepBy` (char ',')
    Attoparsec.string ")"
    pure $ Polygon points
