{-|
Module: IHP.Hasql.FromRow
Description: Typeclass for decoding hasql result rows
Copyright: (c) digitally induced GmbH, 2025

This module provides 'FromRowHasql', a typeclass parallel to postgresql-simple's 'FromRow',
for decoding database rows using hasql's more efficient prepared statement approach.

Instances are generated by the SchemaCompiler with explicit inline decoders in idiomatic
hasql applicative style.

Also provides parser functions used by the generated decoders for custom PostgreSQL types
like Point, Polygon, and TSVector.
-}
module IHP.Hasql.FromRow
( FromRowHasql (..)
, parsePointText
, parsePolygonText
, parseTSVectorText
-- Re-export Hasql.Decoders for generated Types.hs (so apps don't need hasql as direct dependency)
, module Decoders
) where

import IHP.Prelude
import qualified Hasql.Decoders as Decoders
import IHP.Postgres.Point (Point(..))
import IHP.Postgres.Polygon (Polygon(..))
import IHP.Postgres.TSVector (TSVector(..), Lexeme(..), LexemeRanking(..))
import qualified Data.Text.Encoding as Text
import qualified Data.Attoparsec.ByteString.Char8 as Attoparsec
import Data.Attoparsec.ByteString.Char8 (skipSpace, char, option, choice, double, skipMany, many1, many', sepBy)

-- | Typeclass for types that can be decoded from a hasql result row
--
-- This is the hasql equivalent of postgresql-simple's 'FromRow' class.
-- The SchemaCompiler generates instances for all model types using idiomatic
-- hasql applicative style with explicit inline decoders.
class FromRowHasql a where
    -- | Decoder for a single row
    hasqlRowDecoder :: Decoders.Row a

-- Parser functions for custom PostgreSQL types
-- These are used by the generated decoders via Decoders.refine

-- | Parse tsvector text representation to TSVector
-- Format: 'word1':1A,2B 'word2':3C
parseTSVectorText :: ByteString -> Either Text TSVector
parseTSVectorText bs = case Attoparsec.parseOnly parseTSVector bs of
    Left err -> Left (cs err)
    Right val -> Right val

-- | Attoparsec parser for tsvector format
-- This matches the parser in IHP.Postgres.TSVector
parseTSVector :: Attoparsec.Parser TSVector
parseTSVector = TSVector <$> many' parseLexeme
    where
        parseLexeme = do
            skipSpace
            char '\''
            token <- Attoparsec.takeWhile (/= '\'')
            char '\''
            char ':'
            ranking <- many1 do
                skipMany $ char ','
                position <- double
                -- The Default Weight Is `D` So Postgres Does Not Include It In The Result
                weight <- option 'D' $ choice [char 'A', char 'B', char 'C', char 'D']
                pure $ LexemeRanking { position = truncate position, weight }
            pure $ Lexeme { token = Text.decodeUtf8 token, ranking }

-- | Parse point text representation to Point
-- Format: (x,y)
parsePointText :: ByteString -> Either Text Point
parsePointText bs = case Attoparsec.parseOnly parsePoint bs of
    Left err -> Left (cs err)
    Right val -> Right val

-- | Attoparsec parser for point format
-- This matches the parser in IHP.Postgres.Point
parsePoint :: Attoparsec.Parser Point
parsePoint = do
    Attoparsec.string "("
    x <- doubleOrNaN
    Attoparsec.string ","
    y <- doubleOrNaN
    Attoparsec.string ")"
    pure $ Point { x, y }
    where
        -- Postgres supports storing NaN inside a point
        doubleOrNaN = double <|> (Attoparsec.string "NaN" >> (pure $ 0 / 0))

-- | Parse polygon text representation to Polygon
-- Format: ((x1,y1),(x2,y2),...)
parsePolygonText :: ByteString -> Either Text Polygon
parsePolygonText bs = case Attoparsec.parseOnly parsePolygon bs of
    Left err -> Left (cs err)
    Right val -> Right val

-- | Attoparsec parser for polygon format
-- This matches the parser in IHP.Postgres.Polygon
parsePolygon :: Attoparsec.Parser Polygon
parsePolygon = do
    Attoparsec.string "("
    points <- parsePoint `Attoparsec.sepBy` (char ',')
    Attoparsec.string ")"
    pure $ Polygon points
