{-# LANGUAGE FlexibleInstances, UndecidableInstances #-}
{-|
Module: IHP.Hasql.FromRow
Description: Typeclass for decoding hasql result rows
Copyright: (c) digitally induced GmbH, 2025

This module provides 'FromRowHasql', a typeclass parallel to postgresql-simple's 'FromRow',
for decoding database rows using hasql's more efficient prepared statement approach.

Instances are generated by the SchemaCompiler with explicit inline decoders in idiomatic
hasql applicative style.

Also provides parser functions used by the generated decoders for custom PostgreSQL types
like Point, Polygon, and TSVector.
-}
module IHP.Hasql.FromRow
( FromRowHasql (..)
, HasqlDecodeValue (..)
, HasqlDecodeColumn (..)
, parsePointText
, parsePolygonText
, parseTSVectorText
) where

import Prelude
import Data.ByteString (ByteString)
import Data.Text (Text)
import Data.UUID (UUID)
import Data.Time.Clock (UTCTime, DiffTime)
import Data.Time.Calendar (Day)
import Data.Time.LocalTime (TimeOfDay)
import Data.String.Conversions (cs)
import Control.Applicative ((<|>))
import qualified Hasql.Decoders as Decoders
import IHP.Postgres.Point (Point(..))
import IHP.Postgres.Polygon (Polygon(..))
import IHP.Postgres.TSVector (TSVector(..), Lexeme(..), LexemeRanking(..))
import qualified Data.Text.Encoding as Text
import qualified Data.Attoparsec.ByteString.Char8 as Attoparsec
import Data.Attoparsec.ByteString.Char8 (skipSpace, char, option, choice, double, skipMany, many1, many', sepBy)
import Data.Int (Int16, Int32, Int64)
import Data.Scientific (Scientific)
import qualified Data.Aeson as Aeson
import qualified Database.PostgreSQL.Simple.Types as PG
import IHP.ModelSupport.Types (LabeledData(..))

-- | Typeclass for types that can be decoded from a hasql result row
--
-- This is the hasql equivalent of postgresql-simple's 'FromRow' class.
-- The SchemaCompiler generates instances for all model types using idiomatic
-- hasql applicative style with explicit inline decoders.
class FromRowHasql a where
    -- | Decoder for a single row
    hasqlRowDecoder :: Decoders.Row a

-- Parser functions for custom PostgreSQL types
-- These are used by the generated decoders via Decoders.refine

-- | Parse tsvector text representation to TSVector
-- Format: 'word1':1A,2B 'word2':3C
parseTSVectorText :: ByteString -> Either Text TSVector
parseTSVectorText bs = case Attoparsec.parseOnly parseTSVector bs of
    Left err -> Left (cs err)
    Right val -> Right val

-- | Attoparsec parser for tsvector format
-- This matches the parser in IHP.Postgres.TSVector
parseTSVector :: Attoparsec.Parser TSVector
parseTSVector = TSVector <$> many' parseLexeme
    where
        parseLexeme = do
            skipSpace
            char '\''
            token <- Attoparsec.takeWhile (/= '\'')
            char '\''
            char ':'
            ranking <- many1 do
                skipMany $ char ','
                position <- double
                -- The Default Weight Is `D` So Postgres Does Not Include It In The Result
                weight <- option 'D' $ choice [char 'A', char 'B', char 'C', char 'D']
                pure $ LexemeRanking { position = truncate position, weight }
            pure $ Lexeme { token = Text.decodeUtf8 token, ranking }

-- | Parse point text representation to Point
-- Format: (x,y)
parsePointText :: ByteString -> Either Text Point
parsePointText bs = case Attoparsec.parseOnly parsePoint bs of
    Left err -> Left (cs err)
    Right val -> Right val

-- | Attoparsec parser for point format
-- This matches the parser in IHP.Postgres.Point
parsePoint :: Attoparsec.Parser Point
parsePoint = do
    Attoparsec.string "("
    x <- doubleOrNaN
    Attoparsec.string ","
    y <- doubleOrNaN
    Attoparsec.string ")"
    pure $ Point { x, y }
    where
        -- Postgres supports storing NaN inside a point
        doubleOrNaN = double <|> (Attoparsec.string "NaN" >> (pure $ 0 / 0))

-- | Parse polygon text representation to Polygon
-- Format: ((x1,y1),(x2,y2),...)
parsePolygonText :: ByteString -> Either Text Polygon
parsePolygonText bs = case Attoparsec.parseOnly parsePolygon bs of
    Left err -> Left (cs err)
    Right val -> Right val

-- | Attoparsec parser for polygon format
-- This matches the parser in IHP.Postgres.Polygon
parsePolygon :: Attoparsec.Parser Polygon
parsePolygon = do
    Attoparsec.string "("
    points <- parsePoint `Attoparsec.sepBy` (char ',')
    Attoparsec.string ")"
    pure $ Polygon points

-- | Typeclass mapping Haskell scalar types to hasql value decoders
class HasqlDecodeValue a where
    hasqlDecodeValue :: Decoders.Value a

instance HasqlDecodeValue Int16 where hasqlDecodeValue = Decoders.int2
instance HasqlDecodeValue Int32 where hasqlDecodeValue = Decoders.int4
instance HasqlDecodeValue Int64 where hasqlDecodeValue = Decoders.int8
instance HasqlDecodeValue Int where hasqlDecodeValue = fromIntegral <$> Decoders.int8
instance HasqlDecodeValue Bool where hasqlDecodeValue = Decoders.bool
instance HasqlDecodeValue Text where hasqlDecodeValue = Decoders.text
instance HasqlDecodeValue ByteString where hasqlDecodeValue = Decoders.bytea
instance HasqlDecodeValue UUID where hasqlDecodeValue = Decoders.uuid
instance HasqlDecodeValue UTCTime where hasqlDecodeValue = Decoders.timestamptz
instance HasqlDecodeValue Day where hasqlDecodeValue = Decoders.date
instance HasqlDecodeValue TimeOfDay where hasqlDecodeValue = Decoders.time
instance HasqlDecodeValue DiffTime where hasqlDecodeValue = Decoders.interval
instance HasqlDecodeValue Scientific where hasqlDecodeValue = Decoders.numeric
instance HasqlDecodeValue Double where hasqlDecodeValue = Decoders.float8
instance HasqlDecodeValue Float where hasqlDecodeValue = Decoders.float4
instance HasqlDecodeValue Aeson.Value where hasqlDecodeValue = Decoders.jsonb

-- | Typeclass for building column-level row decoders, handling nullable/non-nullable
class HasqlDecodeColumn a where
    hasqlColumnDecoder :: Decoders.Row a

instance {-# OVERLAPPABLE #-} HasqlDecodeValue a => HasqlDecodeColumn a where
    hasqlColumnDecoder = Decoders.column (Decoders.nonNullable hasqlDecodeValue)

instance {-# OVERLAPPING #-} HasqlDecodeValue a => HasqlDecodeColumn (Maybe a) where
    hasqlColumnDecoder = Decoders.column (Decoders.nullable hasqlDecodeValue)

-- FromRowHasql instances for PG.Only and tuples (used by sqlQuery callers like fetchCount, fetchExists)

instance HasqlDecodeColumn a => FromRowHasql (PG.Only a) where
    hasqlRowDecoder = PG.Only <$> hasqlColumnDecoder

instance (HasqlDecodeColumn a, HasqlDecodeColumn b) => FromRowHasql (a, b) where
    hasqlRowDecoder = (,) <$> hasqlColumnDecoder <*> hasqlColumnDecoder

instance (HasqlDecodeColumn a, HasqlDecodeColumn b, HasqlDecodeColumn c) => FromRowHasql (a, b, c) where
    hasqlRowDecoder = (,,) <$> hasqlColumnDecoder <*> hasqlColumnDecoder <*> hasqlColumnDecoder

instance (HasqlDecodeColumn a, HasqlDecodeColumn b, HasqlDecodeColumn c, HasqlDecodeColumn d) => FromRowHasql (a, b, c, d) where
    hasqlRowDecoder = (,,,) <$> hasqlColumnDecoder <*> hasqlColumnDecoder <*> hasqlColumnDecoder <*> hasqlColumnDecoder

instance (HasqlDecodeColumn a, HasqlDecodeColumn b, HasqlDecodeColumn c, HasqlDecodeColumn d, HasqlDecodeColumn e) => FromRowHasql (a, b, c, d, e) where
    hasqlRowDecoder = (,,,,) <$> hasqlColumnDecoder <*> hasqlColumnDecoder <*> hasqlColumnDecoder <*> hasqlColumnDecoder <*> hasqlColumnDecoder

instance (HasqlDecodeColumn label, FromRowHasql a) => FromRowHasql (LabeledData label a) where
    hasqlRowDecoder = LabeledData <$> hasqlColumnDecoder <*> hasqlRowDecoder
